gdb.execute("b tee_entry_std")

Usata per settare un breakpoint

-------------------------------------------

Come imposto un breakpoint su user_ta_enter?

Te lo dico io:
	(gdb) source gdb-optee.py
	(gdb) load_tee
	(gdb) b user_ta.c:user_ta_enter

Ora, come avvio l'esecuzione per far scattare questo breakpoint?
Perché se poi carichi load_host hello_world, si perde la precedente tabella e se non carichi
hello_world, non saprei come avviarla

Se modifichiamo load_host hello_world per includere questo pezzo di codice:
	gdb.execute("symbol-file {}/{}".format(OPTEE_PROJ_PATH, TEE_ELF))
			gdb.execute("b tee_entry_std")

La funzione invoke di LoadHost (N.B. LoadHost, non LoadTA, ho controllato), diventerebbe così:
	# Parte di load_tee per caricare il breakpoint in user_ta_enter
	gdb.execute("symbol-file {}/{}".format(OPTEE_PROJ_PATH, TEE_ELF))
        gdb.execute("b tee_entry_std")
	# Parte pre-esistente che carica i breakpoint della Trusted Application da eseguire
	gdb.execute("add-symbol-file {}/{} {}".format(OPTEE_PROJ_PATH, ta, TA_LOAD_ADDR))
        gdb.execute("b TA_InvokeCommandEntryPoint")


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Loading TEE core symbols for OP-TEE!
Breakpoint 1 at 0xe135866: file core/arch/arm/tee/entry_std.c, line 475.
Breakpoint 2 at 0xe100fe4: file core/arch/arm/kernel/user_ta.c, line 129.
add symbol table from file "/home/luca/Optee/out-br/build/optee_examples-1.0/hello_world/ta/out/8aaaf200-2450-11e4-abe2-0002a5d5c51b.elf" at
	.text_addr = 0x4000d020
Breakpoint 3 at 0x4001877c: file hello_world_ta.c, line 147.

D/LD:  ldelf:169 ELF (8aaaf200-2450-11e4-abe2-0002a5d5c51b) at 0x125000

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/luca/Optee/optee_os/core/tee/uuid.c
/home/luca/Optee/optee_os/core/arch/arm/kernel/user_ta.c
/home/luca/Optee/out-br/build/optee_examples-1.0/hello_world/ta/hello_world_ta.c
/home/luca/Optee/out-br/build/optee_examples-1.0/hello_world/ta/include/hello_world_ta.h
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In user_ta.h c'è la struct user_ta_ctx
kernel/user_ta.h

(gdb) b user_ta.c:138	# Prendiamo il load address del TA (da testare)
(gbd) p (uaddr_t *)&utc->entry_func 
(gdb) p (int) &utc->uctx->ctx->uuid


entry_func = D/LD + 32 (numeri interi)